import { cryptography } from '@liskhq/lisk-client';
import PropTypes from 'prop-types';
import React from 'react';
import { Input } from '../../toolbox/inputs';
import { PrimaryButton, TertiaryButton } from '../../toolbox/buttons/button';
import { parseSearchParams } from '../../../utils/searchParams';
import Box from '../../toolbox/box';
import Icon from '../../toolbox/icon';
import Tooltip from '../../toolbox/tooltip/tooltip';

export default class VerifyMessageInput extends React.Component {
  constructor(props) {
    super(props);

    const { t } = props;

    this.inputs = [
      {
        name: 'message',
        placeholder: t('Write a message'),
        label: t('Message'),
      }, {
        name: 'publicKey',
        placeholder: t('Public key'),
        label: t('Public key'),
      }, {
        name: 'signature',
        placeholder: t('Signature'),
        label: t('Signature'),
        type: 'textarea',
      },
    ];

    this.textarea = {
      name: 'signedMessage',
      placeholder: t('Enter the entire signature generated by Lisk Hub'),
      label: t('Signed Message'),
      type: 'textarea',
    };

    this.state = {
      inputs: [...this.inputs, this.textarea].reduce((inputs, { name }) => ({
        ...inputs,
        [name]: {
          value: parseSearchParams(props.history.location.search)[name] || '',
          feedback: '',
        },
      }), {}),
      isInputsView: true,
    };

    this.goNext = this.goNext.bind(this);
    this.handleChange = this.handleChange.bind(this);
  }

  getInputError({ target: { name, value } }) {
    const { t } = this.props;
    const validators = {
      publicKey: () => {
        try {
          cryptography.getAddressFromPublicKey(value);
          return '';
        } catch (e) {
          return t('This is not a valid public key. Please enter the correct public key.');
        }
      },
    };
    return validators[name] ? validators[name]() : '';
  }

  handleChange({ target }) {
    this.setState({
      inputs: {
        ...this.state.inputs,
        [target.name]: {
          value: target.value,
          feedback: this.getInputError({ target }),
        },
      },
    });
  }

  goNext() {
    const { inputs } = this.state;
    let isCorrect = false;
    try {
      isCorrect = cryptography.verifyMessageWithPublicKey({
        message: inputs.message.value,
        signature: inputs.signature.value,
        publicKey: inputs.publicKey.value,
      });
    } catch (e) {
      isCorrect = false;
    }
    this.props.nextStep({ isCorrect });
  }

  changeView(isInputsView) {
    this.setState({ isInputsView });
  }

  render() {
    const { t, history } = this.props;
    const { inputs, isInputsView } = this.state;

    return (
      <Box main>
        <Box.Header>
          <h1>{t('Verify message')}</h1>
        </Box.Header>
        <Box.Content>
          <Box.InfoText>
            {t('Use this tool to verify the validity of a signed message. This allows you to ensure that the person who signed the message was in fact the account owner')}
            <Tooltip className="showOnBottom">
              <p>{t('If you would like to ensure the ownership of another account, you can send a message via Lisk Hub and request the recipient to sign it.')}</p>
            </Tooltip>
          </Box.InfoText>
          <div>
            {t('Input view')}
            <Icon
              className="inputs-view-icon"
              name={!isInputsView ? 'dashboardIcon' : 'dashboardIconActive'}
              onClick={this.changeView.bind(this, true)}
            />
            <Icon
              className="textarea-view-icon"
              name={isInputsView ? 'academy' : 'academyActive'}
              onClick={this.changeView.bind(this, false)}
            />
          </div>
          {(isInputsView ? this.inputs : [this.textarea]).map(({ name, placeholder, label }) => (
            <Input
              key={name}
              name={name}
              className={name}
              placeholder={placeholder}
              label={label}
              value={inputs[name].value}
              error={!!inputs[name].feedback}
              feedback={inputs[name].feedback}
              onChange={this.handleChange}
            />
          ))}
        </Box.Content>
        <Box.Footer>
          <PrimaryButton onClick={this.goNext} className="continue">{t('Continue')}</PrimaryButton>
          <TertiaryButton onClick={history.goBack} className="go-back">{t('Go back')}</TertiaryButton>
        </Box.Footer>
      </Box>
    );
  }
}

VerifyMessageInput.propTypes = {
  history: PropTypes.object.isRequired,
  nextStep: PropTypes.func,
  t: PropTypes.func.isRequired,
};
